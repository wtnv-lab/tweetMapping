<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no">
  <title>東日本大震災ツイートAR</title>
  <style>
    html, body {
      margin: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: "Hiragino Sans", "Yu Gothic", sans-serif;
      background: #000;
      color: #f3f6fa;
    }

    #arScene {
      position: fixed;
      inset: 0;
      z-index: 1;
    }

    #cameraFeed {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      z-index: 0;
      background: #000;
    }

    #markerLayer {
      position: fixed;
      inset: 0;
      z-index: 2;
      pointer-events: none;
      overflow: hidden;
    }

    .screen-marker {
      position: absolute;
      left: 0;
      top: 0;
      display: inline-flex;
      align-items: center;
      gap: 0.28em;
      transform: translate(-50%, -50%);
      transform-origin: center center;
      pointer-events: auto;
      user-select: none;
      -webkit-user-select: none;
      white-space: nowrap;
      color: #ffffff;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.85), 0 0 12px rgba(0, 0, 0, 0.5);
      line-height: 1;
      font-weight: 700;
    }

    .screen-marker.selected {
      filter: drop-shadow(0 0 10px rgba(80, 170, 255, 0.9));
      transform: translate(-50%, -50%) scale(1.08);
    }

    .screen-marker-icon {
      width: 1em;
      height: 1em;
      display: block;
      flex: 0 0 auto;
    }

    .screen-marker-label {
      display: inline-block;
    }

    .overlay {
      position: fixed;
      left: 0;
      right: 0;
      z-index: 4;
      pointer-events: none;
    }

    #centerPanel {
      inset: 0;
      padding: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #centerPanel.hidden {
      display: none;
    }

    #launchCard {
      width: min(88vw, 420px);
      border: 1px solid rgba(255, 255, 255, 0.24);
      border-radius: 16px;
      background: linear-gradient(160deg, rgba(17, 29, 45, 0.78), rgba(31, 67, 100, 0.56));
      box-shadow: 0 14px 42px rgba(0, 0, 0, 0.36), inset 0 1px 0 rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      padding: 16px 16px 14px 16px;
      pointer-events: auto;
      text-align: center;
    }

    #launchTitle {
      margin: 0 0 8px 0;
      font-size: 17px;
      line-height: 1.35;
      font-weight: 700;
      letter-spacing: 0.01em;
      color: rgba(242, 248, 255, 0.95);
    }

    #launchStatus {
      margin: 0;
      font-size: 12px;
      line-height: 1.4;
      color: rgba(231, 240, 250, 0.88);
    }

    #startButton {
      margin-top: 12px;
      border: 1px solid rgba(165, 214, 255, 0.58);
      border-radius: 12px;
      background: linear-gradient(160deg, rgba(66, 148, 221, 0.86), rgba(41, 104, 168, 0.84));
      box-shadow: 0 8px 18px rgba(0, 0, 0, 0.28), inset 0 1px 0 rgba(255, 255, 255, 0.24);
      color: #f3f6fa;
      height: 40px;
      padding: 0 20px;
      font-size: 15px;
      font-weight: 700;
      letter-spacing: 0.02em;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    #statusStrip {
      bottom: 0;
      padding: 7px 8px calc(7px + env(safe-area-inset-bottom));
      display: flex;
      justify-content: center;
    }

    #statusText {
      margin: 0;
      font-size: 10px;
      line-height: 1.25;
      letter-spacing: 0.02em;
      color: rgba(238, 245, 252, 0.7);
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.85);
      text-align: center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 96vw;
    }

    #tweetCard {
      position: fixed;
      left: 0;
      top: 0;
      width: min(88vw, 420px);
      min-height: 48px;
      border: 1px solid rgba(255, 255, 255, 0.28);
      border-radius: 12px;
      background: rgba(20, 24, 30, 0.72);
      box-shadow: 0 4px 14px rgba(0, 0, 0, 0.22);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      padding: 10px 12px;
      pointer-events: auto;
      opacity: 0;
      visibility: hidden;
      transform: translate(-50%, -8px);
      transition: opacity 200ms ease, transform 200ms ease, visibility 200ms ease;
      z-index: 4;
    }

    #tweetCard.visible {
      opacity: 1;
      visibility: visible;
      transform: translate(-50%, 0);
    }

    #tweetBody {
      margin: 0;
      font-size: 13px;
      line-height: 1.45;
      color: #f3f6fa;
      white-space: pre-wrap;
      word-break: break-word;
    }

    #tweetMeta {
      margin: 8px 0 0 0;
      font-size: 12px;
      line-height: 1.3;
      color: rgba(243, 246, 250, 0.9);
      letter-spacing: 0.02em;
    }
  </style>
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/ar.js@3.4.5/aframe/build/aframe-ar.js"></script>
</head>
<body>
  <div class="overlay" id="centerPanel">
    <div id="launchCard">
      <p id="launchTitle">東日本大震災 ツイートAR</p>
      <p id="launchStatus">「開始」を押してカメラ・位置情報を許可してください。</p>
      <button id="startButton" type="button">開始</button>
    </div>
  </div>

  <div class="overlay" id="statusStrip">
    <p id="statusText">待機中</p>
  </div>

  <video id="cameraFeed" autoplay playsinline muted></video>
  <div id="arRoot"></div>
  <div id="markerLayer"></div>
  <div id="tweetCard">
    <p id="tweetBody">近くのツイートが見つかるとここに本文を表示します。</p>
    <p id="tweetMeta">ここから -m</p>
  </div>

  <script>
    (function () {
      const statusText = document.getElementById("statusText");
      const centerPanel = document.getElementById("centerPanel");
      const launchStatus = document.getElementById("launchStatus");
      const startButton = document.getElementById("startButton");
      const tweetCard = document.getElementById("tweetCard");
      const tweetBody = document.getElementById("tweetBody");
      const tweetMeta = document.getElementById("tweetMeta");
      const arRoot = document.getElementById("arRoot");
      const cameraFeed = document.getElementById("cameraFeed");
      const markerLayer = document.getElementById("markerLayer");

      const tweetDataUrl = "data/czml/tweets.json";
      const twitterIconUrl = "data/icon/flags/twitter.png";
      const maxMarkers = 100;
      const markerRadiusMeters = 10000;
      const rebuildThresholdMeters = 30;
      const locationPollIntervalMs = 5000;
      const minBuildIntervalMs = 1200;
      const maxLabelChars = 26;

      let allTweets = [];
      let currentPosition = null;
      let lastBuildPosition = null;
      let markerEntities = [];
      let dataLoaded = false;
      let scene = null;
      let cameraStream = null;
      let locationPollTimer = null;
      let deviceHeading = null;
      let renderedMarkerCount = 0;
      let nearbyCandidateCount = 0;
      let nearestDistanceMeters = null;
      let selectedMarker = null;
      let lastBuildAt = 0;
      let buildTimer = null;
      let markerRenderFrame = null;
      const projectedPoint = new THREE.Vector3();
      const cameraSpacePoint = new THREE.Vector3();

      function scheduleBuild(forceNow) {
        if (forceNow) {
          if (buildTimer !== null) {
            clearTimeout(buildTimer);
            buildTimer = null;
          }
          buildMarkers();
          return;
        }
        const wait = Math.max(0, minBuildIntervalMs - (Date.now() - lastBuildAt));
        if (wait === 0) {
          buildMarkers();
          return;
        }
        if (buildTimer !== null) {
          return;
        }
        buildTimer = setTimeout(function () {
          buildTimer = null;
          buildMarkers();
        }, wait);
      }

      function setStatus(message) {
        statusText.textContent = message;
      }

      function setLaunchStatus(message) {
        launchStatus.textContent = message;
      }

      function hideLaunchPanel() {
        centerPanel.classList.add("hidden");
      }

      function bindSceneEvents(targetScene) {
        targetScene.addEventListener("loaded", function () {
          setStatus("ARシーン起動完了。位置情報を待っています...");
        });
        const onBackgroundTap = function (event) {
          if (!isTweetHitTarget(event.target)) {
            clearSelection();
          }
        };
        targetScene.addEventListener("click", onBackgroundTap);
        targetScene.addEventListener("touchstart", onBackgroundTap, { passive: true });
      }

      function createScene() {
        arRoot.innerHTML =
          '<a-scene id="arScene" embedded vr-mode-ui="enabled: false" renderer="antialias: true; alpha: true; logarithmicDepthBuffer: true;">' +
          '<a-assets timeout="10000"><img id="twitterIconAsset" src="' +
          twitterIconUrl +
          '" crossorigin="anonymous"></a-assets>' +
          '<a-entity id="arCamera" camera="fov: 108; near: 0.05; far: 12000" look-controls="enabled: true; magicWindowTrackingEnabled: true; touchEnabled: true" wasd-controls="enabled: false" cursor="rayOrigin: mouse" raycaster="objects: .tweet-hit; far: 12000" position="0 1.6 0"></a-entity>' +
          "</a-scene>";
        scene = document.getElementById("arScene");
        bindSceneEvents(scene);
      }

      function haversineMeters(lat1, lon1, lat2, lon2) {
        const toRad = Math.PI / 180.0;
        const dLat = (lat2 - lat1) * toRad;
        const dLon = (lon2 - lon1) * toRad;
        const a =
          Math.sin(dLat / 2) * Math.sin(dLat / 2) +
          Math.cos(lat1 * toRad) * Math.cos(lat2 * toRad) *
          Math.sin(dLon / 2) * Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return 6371000 * c;
      }

      function bearingDegrees(lat1, lon1, lat2, lon2) {
        const toRad = Math.PI / 180.0;
        const y = Math.sin((lon2 - lon1) * toRad) * Math.cos(lat2 * toRad);
        const x =
          Math.cos(lat1 * toRad) * Math.sin(lat2 * toRad) -
          Math.sin(lat1 * toRad) * Math.cos(lat2 * toRad) * Math.cos((lon2 - lon1) * toRad);
        const brng = (Math.atan2(y, x) * 180) / Math.PI;
        return (brng + 360) % 360;
      }

      function clamp(value, min, max) {
        return Math.min(max, Math.max(min, value));
      }

      function clearMarkers() {
        clearSelection();
        if (buildTimer !== null) {
          clearTimeout(buildTimer);
          buildTimer = null;
        }
        for (let i = 0; i < markerEntities.length; i++) {
          const marker = markerEntities[i].root;
          if (marker && marker.parentNode) {
            marker.parentNode.removeChild(marker);
          }
        }
        markerEntities = [];
      }

      function toLabel(text) {
        const normalized = String(text || "").replace(/\s+/g, " ").trim();
        if (normalized.length <= maxLabelChars) {
          return normalized;
        }
        return normalized.slice(0, maxLabelChars - 3) + "...";
      }

      function setMarkerSelected(marker, selected) {
        if (!marker) {
          return;
        }
        const root = marker.root;
        const iconBaseOpacity = marker.iconBaseOpacity;
        const labelBaseOpacity = marker.labelBaseOpacity;
        marker.icon.style.opacity = String(selected ? 1.0 : iconBaseOpacity);
        marker.label.style.opacity = String(selected ? 1.0 : labelBaseOpacity);
        if (selected) {
          root.classList.add("selected");
        } else {
          root.classList.remove("selected");
        }
      }

      function clearSelection() {
        if (selectedMarker) {
          setMarkerSelected(selectedMarker, false);
          selectedMarker = null;
        }
        tweetCard.classList.remove("visible");
      }

      function isTweetHitTarget(target) {
        return !!(target && target.closest && target.closest(".screen-marker"));
      }

      function selectMarker(marker) {
        if (!marker) {
          return;
        }
        if (selectedMarker && selectedMarker !== marker) {
          setMarkerSelected(selectedMarker, false);
        }
        selectedMarker = marker;
        setMarkerSelected(marker, true);
        const body = marker.tweetText || "";
        const dist = marker.distanceMeters || "-";
        tweetBody.textContent = body;
        tweetMeta.textContent = "ここから " + dist + "m";
        positionTweetCard(marker);
        tweetCard.classList.add("visible");
      }

      function positionTweetCard(marker) {
        if (!marker || !marker.root) {
          return;
        }
        const rect = marker.root.getBoundingClientRect();
        const viewportW = window.innerWidth;
        const viewportH = window.innerHeight;
        const cardW = Math.min(viewportW * 0.88, 420);
        const cardH = 96;
        const margin = 12;
        let x = rect.left + rect.width * 0.5;
        x = clamp(x, cardW * 0.5 + margin, viewportW - cardW * 0.5 - margin);
        let y = rect.top - margin;
        if (y - cardH < margin) {
          y = rect.bottom + margin + cardH;
        }
        y = clamp(y, cardH + margin, viewportH - margin);
        tweetCard.style.left = x.toFixed(1) + "px";
        tweetCard.style.top = y.toFixed(1) + "px";
      }

      function projectToScreen(worldPosition, cameraObj, width, height) {
        cameraSpacePoint.copy(worldPosition).applyMatrix4(cameraObj.matrixWorldInverse);
        if (cameraSpacePoint.z >= -0.01) {
          return null;
        }
        projectedPoint.copy(worldPosition).project(cameraObj);
        if (projectedPoint.z < -1 || projectedPoint.z > 1) {
          return null;
        }
        const x = (projectedPoint.x * 0.5 + 0.5) * width;
        const y = (-projectedPoint.y * 0.5 + 0.5) * height;
        // Y is clamped later by UI layout logic; avoid hiding markers on strong tilt.
        if (x < -220 || x > width + 220) {
          return null;
        }
        return { x: x, y: y };
      }

      function updateScreenMarkers() {
        if (!scene || markerEntities.length === 0) {
          return;
        }
        const camEntity = scene.querySelector("#arCamera");
        if (!camEntity) {
          return;
        }
        const cameraObj = camEntity.getObject3D("camera");
        if (!cameraObj) {
          return;
        }
        cameraObj.updateMatrixWorld(true);
        const width = window.innerWidth;
        const height = window.innerHeight;
        const offscreenMargin = 48;
        for (let i = 0; i < markerEntities.length; i++) {
          const marker = markerEntities[i];
          const screenPos = projectToScreen(marker.worldPosition, cameraObj, width, height);
          if (!screenPos) {
            marker.root.style.display = "none";
            continue;
          }
          const xScatter = (marker.laneOffset * 34 + marker.clusterOffset * 56) * (0.8 + marker.distanceNorm * 1.2);
          const rawYScatter = (marker.laneOffset * 17.5 + marker.clusterOffset * 30) * (0.4375 + marker.distanceNorm * 0.6875);
          const yScatter = rawYScatter < 0 ? rawYScatter * 1.25 : rawYScatter;
          const distanceYOffset = (marker.distanceNorm - 0.5) * height * 0.56;
          const targetX = screenPos.x * 0.85 + (width * 0.5) * 0.15 + xScatter;
          const tiltPivotY = height * 0.35;
          const tiltReducedY = tiltPivotY + (screenPos.y - tiltPivotY) * 0.52;
          const limitedTiltY = clamp(tiltReducedY, tiltPivotY - height * 0.14, tiltPivotY + height * 0.14);
          const targetY = clamp(limitedTiltY + distanceYOffset + yScatter, height * -0.04, height * 0.7);
          if (typeof marker.screenX !== "number" || typeof marker.screenY !== "number") {
            marker.screenX = targetX;
            marker.screenY = targetY;
          } else {
            // Smooth sensor jitter while preserving follow responsiveness.
            marker.screenX += (targetX - marker.screenX) * 0.22;
            marker.screenY += (targetY - marker.screenY) * 0.22;
          }
          if (
            marker.screenX < -offscreenMargin ||
            marker.screenX > width + offscreenMargin ||
            marker.screenY < -offscreenMargin ||
            marker.screenY > height + offscreenMargin
          ) {
            marker.root.style.display = "none";
            continue;
          }
          marker.root.style.display = "inline-flex";
          marker.root.style.left = marker.screenX.toFixed(1) + "px";
          marker.root.style.top = marker.screenY.toFixed(1) + "px";
          marker.root.style.zIndex = String(10000 - Math.round(marker.distanceNorm * 8000));
        }
        if (selectedMarker && selectedMarker.root) {
          if (selectedMarker.root.style.display === "none") {
            clearSelection();
          } else {
            positionTweetCard(selectedMarker);
          }
        }
      }

      function startMarkerRenderLoop() {
        if (markerRenderFrame !== null) {
          return;
        }
        const tick = function () {
          markerRenderFrame = requestAnimationFrame(tick);
          updateScreenMarkers();
        };
        markerRenderFrame = requestAnimationFrame(tick);
      }

      function buildMarkers() {
        if (!scene || !currentPosition || !dataLoaded) {
          return;
        }
        lastBuildAt = Date.now();

        const lat = currentPosition.coords.latitude;
        const lon = currentPosition.coords.longitude;
        const candidates = [];

        for (let i = 0; i < allTweets.length; i++) {
          const t = allTweets[i];
          const distance = haversineMeters(lat, lon, t.lat, t.lon);
          if (distance <= markerRadiusMeters) {
            candidates.push({
              tweet: t,
              distance: distance,
            });
          }
        }

        candidates.sort(function (a, b) {
          return a.distance - b.distance;
        });

        clearMarkers();

        const count = Math.min(maxMarkers, candidates.length);
        const nearestDistance = count > 0 ? Math.round(candidates[0].distance) : null;
        const farthestDistance = count > 0 ? candidates[count - 1].distance : null;
        const distanceSpan = farthestDistance !== null && nearestDistance !== null ? Math.max(1, farthestDistance - nearestDistance) : 1;
        const headingNow = deviceHeading === null ? 0 : deviceHeading;
        const laneStepDeg = 2.8;
        const clusterStepDeg = 8.0;
        const laneSlots = new Map();
        const clusterSlots = new Map();
        function directedOffsetUnits(indexInGroup, ratio) {
          if (indexInGroup === 0) {
            return 0;
          }
          // Near tweets: spread upward only. Far tweets: spread downward only.
          if (ratio <= 0.45) {
            return indexInGroup;
          }
          if (ratio >= 0.7) {
            return -indexInGroup;
          }
          const level = Math.floor((indexInGroup + 1) / 2);
          const sign = indexInGroup % 2 === 1 ? 1 : -1;
          return level * sign;
        }
        nearbyCandidateCount = candidates.length;
        renderedMarkerCount = count;
        nearestDistanceMeters = nearestDistance;
        for (let i = 0; i < count; i++) {
          const candidate = candidates[i];
          const t = candidate.tweet;
          const distance = candidate.distance;
          const bearing = bearingDegrees(lat, lon, t.lat, t.lon);
          const relativeDeg = ((bearing - headingNow + 540) % 360) - 180;
          const relativeRad = (relativeDeg * Math.PI) / 180;
          const projected = distance;
          const x = Math.sin(relativeRad) * projected;
          const z = -Math.cos(relativeRad) * projected;
          const ratio = clamp(distance / markerRadiusMeters, 0, 1);
          const distanceNorm = clamp((distance - (nearestDistance !== null ? nearestDistance : distance)) / distanceSpan, 0, 1);
          const laneKey = String(Math.round(relativeDeg / laneStepDeg));
          const laneIndex = laneSlots.get(laneKey) || 0;
          laneSlots.set(laneKey, laneIndex + 1);
          const clusterKey = String(Math.round(relativeDeg / clusterStepDeg));
          const clusterIndex = clusterSlots.get(clusterKey) || 0;
          clusterSlots.set(clusterKey, clusterIndex + 1);
          // Keep vertical offsets small; distance is represented by true depth.
          const baseY = 1.8;
          const spreadStep = 0.45;
          const laneOffset = directedOffsetUnits(laneIndex, ratio);
          const clusterOffset = directedOffsetUnits(clusterIndex, ratio);
          const densityBoost = 1 + Math.min(2.0, clusterIndex * 0.2 + laneIndex * 0.1);
          const combinedOffset = laneOffset + clusterOffset * 1.8;
          const markerY = clamp(baseY + combinedOffset * spreadStep * densityBoost, 0.6, 7.5);
          const iconSize = clamp(86 - distanceNorm * 74, 12, 86);
          const label = toLabel(t.text);
          const labelFontPx = Math.round(clamp(44 - distanceNorm * 34, 10, 44));
          const iconOpacity = clamp(0.98 - distanceNorm * 0.62, 0.36, 0.98);
          const labelOpacity = clamp(0.99 - distanceNorm * 0.68, 0.31, 0.99);
          const worldPosition = new THREE.Vector3(x, markerY, z);

          const root = document.createElement("div");
          root.className = "screen-marker tweet-hit";
          root.style.fontSize = labelFontPx.toFixed(1) + "px";

          const icon = document.createElement("img");
          icon.className = "screen-marker-icon tweet-hit";
          icon.src = twitterIconUrl;
          icon.alt = "";
          icon.style.width = iconSize.toFixed(1) + "px";
          icon.style.height = iconSize.toFixed(1) + "px";
          icon.style.opacity = iconOpacity.toFixed(2);
          root.appendChild(icon);

          const labelSpan = document.createElement("span");
          labelSpan.className = "screen-marker-label tweet-hit";
          labelSpan.textContent = label;
          labelSpan.style.opacity = labelOpacity.toFixed(2);
          root.appendChild(labelSpan);

          const onSelect = function () {
            selectMarker(marker);
          };
          root.addEventListener("click", onSelect);
          root.addEventListener("touchstart", onSelect, { passive: true });
          icon.addEventListener("click", onSelect);
          labelSpan.addEventListener("click", onSelect);
          markerLayer.appendChild(root);

          const marker = {
            root: root,
            icon: icon,
            label: labelSpan,
            worldPosition: worldPosition,
            ratio: ratio,
            distanceNorm: distanceNorm,
            laneOffset: laneOffset,
            clusterOffset: clusterOffset,
            screenX: null,
            screenY: null,
            iconBaseOpacity: iconOpacity,
            labelBaseOpacity: labelOpacity,
            tweetText: t.text,
            distanceMeters: String(Math.round(distance)),
          };
          markerEntities.push(marker);
        }
        updateScreenMarkers();
        const nearestText = nearestDistance !== null ? ", 最短 " + nearestDistance + "m" : "";
        const message =
          "近傍 " +
          candidates.length +
          " 件（表示 " +
          count +
          " 件, 半径 " +
          Math.round(markerRadiusMeters / 1000) +
          "km" +
          nearestText +
          "）";
        setStatus(message);
        lastBuildPosition = {
          latitude: lat,
          longitude: lon,
        };
      }

      function maybeRebuildMarkers() {
        if (!currentPosition) {
          return;
        }
        if (!lastBuildPosition) {
          scheduleBuild(true);
          return;
        }

        const moved = haversineMeters(
          lastBuildPosition.latitude,
          lastBuildPosition.longitude,
          currentPosition.coords.latitude,
          currentPosition.coords.longitude
        );
        if (moved >= rebuildThresholdMeters) {
          scheduleBuild(false);
        }
      }

      function loadTweets() {
        return fetch(tweetDataUrl)
          .then(function (response) {
            if (!response.ok) {
              throw new Error("HTTP " + response.status);
            }
            return response.json();
          })
          .then(function (json) {
            const tweets = [];
            for (let i = 0; i < json.length; i++) {
              const item = json[i];
              const coords = item && item.position && item.position.cartographicDegrees;
              if (!Array.isArray(coords) || coords.length < 2) {
                continue;
              }
              const lon = Number(coords[0]);
              const lat = Number(coords[1]);
              if (!Number.isFinite(lon) || !Number.isFinite(lat)) {
                continue;
              }
              tweets.push({
                id: String(item.id),
                text: String(item.text || ""),
                lat: lat,
                lon: lon,
              });
            }
            allTweets = tweets;
            dataLoaded = true;
          });
      }

      function requestOrientationPermission() {
        if (typeof DeviceOrientationEvent === "undefined") {
          return Promise.resolve();
        }
        if (typeof DeviceOrientationEvent.requestPermission !== "function") {
          return Promise.resolve();
        }
        return DeviceOrientationEvent.requestPermission().then(function (state) {
          if (state !== "granted") {
            throw new Error("方位センサー権限が拒否されました。");
          }
        });
      }

      function bindOrientationDiagnostics() {
        window.addEventListener(
          "deviceorientation",
          function (event) {
            if (typeof event.webkitCompassHeading === "number") {
              deviceHeading = event.webkitCompassHeading;
            } else if (event.absolute && typeof event.alpha === "number") {
              deviceHeading = (360 - event.alpha) % 360;
            }
            if (deviceHeading !== null && currentPosition && dataLoaded && !lastBuildPosition && markerEntities.length === 0) {
              scheduleBuild(true);
            }
          },
          true
        );
      }

      function requestCameraPermission() {
        if (!navigator.mediaDevices || typeof navigator.mediaDevices.getUserMedia !== "function") {
          return Promise.resolve();
        }

        return navigator.mediaDevices
          .getUserMedia({
            video: {
              facingMode: { ideal: "environment" },
            },
            audio: false,
          })
          .then(function (stream) {
            cameraStream = stream;
            cameraFeed.srcObject = stream;
            return cameraFeed.play().catch(function () {
              return Promise.resolve();
            });
          });
      }

      function startLocationPolling() {
        if (!navigator.geolocation) {
          setStatus("この端末は位置情報に対応していません。");
          return;
        }

        const pollPosition = function () {
          navigator.geolocation.getCurrentPosition(
            function (position) {
              currentPosition = position;
              maybeRebuildMarkers();
            },
            function (error) {
              setStatus("位置情報の取得に失敗: " + error.message);
            },
            {
              enableHighAccuracy: false,
              maximumAge: locationPollIntervalMs,
              timeout: 30000,
            }
          );
        };

        pollPosition();
        locationPollTimer = setInterval(pollPosition, locationPollIntervalMs);
      }

      function startAR() {
        setLaunchStatus("データを読み込み中...");
        startButton.disabled = true;
        const orientationPermissionPromise = requestOrientationPermission();
        Promise.all([orientationPermissionPromise, requestCameraPermission()])
          .then(function () {
            setLaunchStatus("ツイートデータを読み込んでいます...");
            return loadTweets();
          })
          .then(function () {
            setLaunchStatus("位置情報を取得しています...");
            createScene();
            bindOrientationDiagnostics();
            startLocationPolling();
            startMarkerRenderLoop();
            startButton.textContent = "起動中";
            setTimeout(function () {
              hideLaunchPanel();
            }, 450);
            setTimeout(function () {
              if (!cameraStream) {
                setStatus("カメラ映像を取得できません。Safari設定のカメラ許可を確認してください。");
              }
            }, 5000);
          })
          .catch(function (error) {
            setLaunchStatus("開始できませんでした: " + error.message);
            startButton.disabled = false;
            startButton.textContent = "開始";
          });
      }

      window.addEventListener("pagehide", function () {
        if (buildTimer !== null) {
          clearTimeout(buildTimer);
          buildTimer = null;
        }
        if (locationPollTimer !== null) {
          clearInterval(locationPollTimer);
          locationPollTimer = null;
        }
        if (markerRenderFrame !== null) {
          cancelAnimationFrame(markerRenderFrame);
          markerRenderFrame = null;
        }
        if (!cameraStream) {
          return;
        }
        const tracks = cameraStream.getTracks ? cameraStream.getTracks() : [];
        for (let i = 0; i < tracks.length; i++) {
          tracks[i].stop();
        }
        cameraStream = null;
      });

      startButton.addEventListener("click", startAR);
    })();
  </script>
</body>
</html>
