<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no">
  <title>東日本大震災ツイートAR</title>
  <style>
    html, body {
      margin: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: "Hiragino Sans", "Yu Gothic", sans-serif;
      background: #000;
      color: #f3f6fa;
    }

    #arScene {
      position: fixed;
      inset: 0;
      z-index: 1;
    }

    #cameraFeed {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      z-index: 0;
      background: #000;
    }

    .overlay {
      position: fixed;
      left: 0;
      right: 0;
      z-index: 3;
      pointer-events: none;
    }

    #topPanel {
      top: 0;
      padding: 12px;
      display: flex;
      justify-content: center;
    }

    #statusCard {
      max-width: 90vw;
      min-width: 280px;
      border: 1px solid rgba(255, 255, 255, 0.28);
      border-radius: 12px;
      background: rgba(20, 24, 30, 0.72);
      box-shadow: 0 4px 14px rgba(0, 0, 0, 0.22);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      padding: 10px 12px;
      pointer-events: auto;
    }

    #statusText {
      margin: 0;
      font-size: 13px;
      line-height: 1.5;
    }

    #startButton {
      margin-top: 8px;
      border: 1px solid rgba(255, 255, 255, 0.35);
      border-radius: 8px;
      background: rgba(52, 114, 168, 0.76);
      color: #f3f6fa;
      height: 34px;
      padding: 0 14px;
      font-size: 13px;
      cursor: pointer;
    }

    #bottomPanel {
      bottom: 0;
      padding: 12px;
      display: flex;
      justify-content: center;
    }

    #tweetCard {
      width: min(92vw, 440px);
      min-height: 48px;
      border: 1px solid rgba(255, 255, 255, 0.28);
      border-radius: 12px;
      background: rgba(20, 24, 30, 0.72);
      box-shadow: 0 4px 14px rgba(0, 0, 0, 0.22);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      padding: 10px 12px;
      pointer-events: auto;
      opacity: 0;
      visibility: hidden;
      transform: translateY(10px);
      transition: opacity 240ms ease, transform 240ms ease, visibility 240ms ease;
    }

    #tweetCard.visible {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
    }

    #tweetBody {
      margin: 0;
      font-size: 13px;
      line-height: 1.45;
      color: #f3f6fa;
      white-space: pre-wrap;
      word-break: break-word;
    }

    #tweetMeta {
      margin: 8px 0 0 0;
      font-size: 12px;
      line-height: 1.3;
      color: rgba(243, 246, 250, 0.9);
      letter-spacing: 0.02em;
    }
  </style>
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/ar.js@3.4.5/aframe/build/aframe-ar.js"></script>
</head>
<body>
  <div class="overlay" id="topPanel">
    <div id="statusCard">
      <p id="statusText">「開始」を押してカメラ・位置情報を許可してください。</p>
      <button id="startButton" type="button">開始</button>
    </div>
  </div>

  <div class="overlay" id="bottomPanel">
    <div id="tweetCard">
      <p id="tweetBody">近くのツイートが見つかるとここに本文を表示します。</p>
      <p id="tweetMeta">ここから -m</p>
    </div>
  </div>

  <video id="cameraFeed" autoplay playsinline muted></video>
  <div id="arRoot"></div>

  <script>
    (function () {
      const statusText = document.getElementById("statusText");
      const startButton = document.getElementById("startButton");
      const tweetCard = document.getElementById("tweetCard");
      const tweetBody = document.getElementById("tweetBody");
      const tweetMeta = document.getElementById("tweetMeta");
      const arRoot = document.getElementById("arRoot");
      const cameraFeed = document.getElementById("cameraFeed");

      const tweetDataUrl = "data/czml/tweets.json";
      const twitterIconUrl = "data/icon/flags/twitter.png";
      const maxMarkers = 100;
      const markerRadiusMeters = 10000;
      const rebuildThresholdMeters = 30;
      const locationPollIntervalMs = 5000;
      const minBuildIntervalMs = 1200;
      const maxLabelChars = 26;

      let allTweets = [];
      let currentPosition = null;
      let lastBuildPosition = null;
      let markerEntities = [];
      let dataLoaded = false;
      let scene = null;
      let cameraStream = null;
      let locationPollTimer = null;
      let deviceHeading = null;
      let renderedMarkerCount = 0;
      let nearbyCandidateCount = 0;
      let nearestDistanceMeters = null;
      let selectedMarker = null;
      const labelTextureCache = new Map();
      let lastBuildAt = 0;
      let buildTimer = null;
      function yawDegreesFacingUser(x, z) {
        if (Math.abs(x) < 0.0001 && Math.abs(z) < 0.0001) {
          return 0;
        }
        return (Math.atan2(-x, -z) * 180) / Math.PI;
      }

      function scheduleBuild(forceNow) {
        if (forceNow) {
          if (buildTimer !== null) {
            clearTimeout(buildTimer);
            buildTimer = null;
          }
          buildMarkers();
          return;
        }
        const wait = Math.max(0, minBuildIntervalMs - (Date.now() - lastBuildAt));
        if (wait === 0) {
          buildMarkers();
          return;
        }
        if (buildTimer !== null) {
          return;
        }
        buildTimer = setTimeout(function () {
          buildTimer = null;
          buildMarkers();
        }, wait);
      }

      function setStatus(message) {
        statusText.textContent = message;
      }

      function bindSceneEvents(targetScene) {
        targetScene.addEventListener("loaded", function () {
          setStatus("ARシーン起動完了。位置情報を待っています...");
        });
        const onBackgroundTap = function (event) {
          if (!isTweetHitTarget(event.target)) {
            clearSelection();
          }
        };
        targetScene.addEventListener("click", onBackgroundTap);
        targetScene.addEventListener("touchstart", onBackgroundTap, { passive: true });
      }

      function createScene() {
        arRoot.innerHTML =
          '<a-scene id="arScene" embedded vr-mode-ui="enabled: false" renderer="antialias: true; alpha: true; logarithmicDepthBuffer: true;">' +
          '<a-assets timeout="10000"><img id="twitterIconAsset" src="' +
          twitterIconUrl +
          '" crossorigin="anonymous"></a-assets>' +
          '<a-entity id="arCamera" camera="fov: 108; near: 0.05; far: 2200" look-controls="enabled: true; magicWindowTrackingEnabled: true; touchEnabled: true" wasd-controls="enabled: false" cursor="rayOrigin: mouse" raycaster="objects: .tweet-hit; far: 1000" position="0 1.6 0"></a-entity>' +
          "</a-scene>";
        scene = document.getElementById("arScene");
        bindSceneEvents(scene);
      }

      function haversineMeters(lat1, lon1, lat2, lon2) {
        const toRad = Math.PI / 180.0;
        const dLat = (lat2 - lat1) * toRad;
        const dLon = (lon2 - lon1) * toRad;
        const a =
          Math.sin(dLat / 2) * Math.sin(dLat / 2) +
          Math.cos(lat1 * toRad) * Math.cos(lat2 * toRad) *
          Math.sin(dLon / 2) * Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return 6371000 * c;
      }

      function bearingDegrees(lat1, lon1, lat2, lon2) {
        const toRad = Math.PI / 180.0;
        const y = Math.sin((lon2 - lon1) * toRad) * Math.cos(lat2 * toRad);
        const x =
          Math.cos(lat1 * toRad) * Math.sin(lat2 * toRad) -
          Math.sin(lat1 * toRad) * Math.cos(lat2 * toRad) * Math.cos((lon2 - lon1) * toRad);
        const brng = (Math.atan2(y, x) * 180) / Math.PI;
        return (brng + 360) % 360;
      }

      function clamp(value, min, max) {
        return Math.min(max, Math.max(min, value));
      }

      function clearMarkers() {
        if (!scene) {
          return;
        }
        clearSelection();
        if (buildTimer !== null) {
          clearTimeout(buildTimer);
          buildTimer = null;
        }
        for (let i = 0; i < markerEntities.length; i++) {
          const marker = markerEntities[i];
          if (marker.parentNode) {
            marker.parentNode.removeChild(marker);
          }
        }
        markerEntities = [];
      }

      function toLabel(text) {
        const normalized = String(text || "").replace(/\s+/g, " ").trim();
        if (normalized.length <= maxLabelChars) {
          return normalized;
        }
        return normalized.slice(0, maxLabelChars - 3) + "...";
      }

      function labelTextureDataUrl(labelText, fontPx) {
        const cacheKey = labelText + "|" + String(fontPx);
        if (labelTextureCache.has(cacheKey)) {
          return labelTextureCache.get(cacheKey);
        }
        const canvas = document.createElement("canvas");
        canvas.width = 2048;
        canvas.height = 480;
        const ctx = canvas.getContext("2d");
        if (!ctx) {
          return { url: "", aspect: 4.0 };
        }
        const marginX = 160;
        const marginY = 100;
        ctx.font = "bold " + fontPx + "px 'Hiragino Sans', 'Yu Gothic', 'Noto Sans JP', sans-serif";
        const measuredWidth = Math.ceil(ctx.measureText(labelText).width);
        canvas.width = Math.max(1024, Math.min(4096, measuredWidth + marginX * 2));
        canvas.height = Math.max(360, Math.min(1200, Math.round(fontPx + marginY * 2)));

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.font = "bold " + fontPx + "px 'Hiragino Sans', 'Yu Gothic', 'Noto Sans JP', sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.lineJoin = "round";
        ctx.lineWidth = clamp(fontPx * 0.22, 14, 36);
        ctx.strokeStyle = "rgba(0,0,0,0.68)";
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        ctx.strokeText(labelText, centerX, centerY);
        ctx.fillStyle = "#ffffff";
        ctx.fillText(labelText, centerX, centerY);
        const texture = {
          url: canvas.toDataURL("image/png"),
          aspect: canvas.width / canvas.height,
        };
        labelTextureCache.set(cacheKey, texture);
        return texture;
      }

      function setMarkerSelected(marker, selected) {
        if (!marker) {
          return;
        }
        const icon = marker.querySelector(".tweet-icon");
        const label = marker.querySelector(".tweet-label");
        const iconBaseOpacity = marker.dataset.iconOpacity || "0.86";
        const labelBaseOpacity = marker.dataset.labelOpacity || "0.9";
        if (icon) {
          icon.setAttribute("opacity", selected ? "1.0" : iconBaseOpacity);
        }
        if (label) {
          label.setAttribute("opacity", selected ? "1.0" : labelBaseOpacity);
        }
        if (selected) {
          marker.setAttribute("animation__pulse", "property: scale; dir: alternate; dur: 520; easing: easeInOutSine; loop: true; to: 1.09 1.09 1.09");
        } else {
          marker.removeAttribute("animation__pulse");
          marker.setAttribute("scale", "1 1 1");
        }
      }

      function clearSelection() {
        if (selectedMarker) {
          setMarkerSelected(selectedMarker, false);
          selectedMarker = null;
        }
        tweetCard.classList.remove("visible");
      }

      function isTweetHitTarget(target) {
        let node = target;
        while (node && node !== scene) {
          if (node.classList && node.classList.contains("tweet-hit")) {
            return true;
          }
          node = node.parentElement;
        }
        return false;
      }

      function selectMarker(marker) {
        if (!marker) {
          return;
        }
        if (selectedMarker && selectedMarker !== marker) {
          setMarkerSelected(selectedMarker, false);
        }
        selectedMarker = marker;
        setMarkerSelected(marker, true);
        const body = marker.dataset.tweetText || "";
        const dist = marker.dataset.distanceMeters || "-";
        tweetBody.textContent = body;
        tweetMeta.textContent = "ここから " + dist + "m";
        tweetCard.classList.add("visible");
      }

      function buildMarkers() {
        if (!scene || !currentPosition || !dataLoaded) {
          return;
        }
        lastBuildAt = Date.now();

        const lat = currentPosition.coords.latitude;
        const lon = currentPosition.coords.longitude;
        const candidates = [];

        for (let i = 0; i < allTweets.length; i++) {
          const t = allTweets[i];
          const distance = haversineMeters(lat, lon, t.lat, t.lon);
          if (distance <= markerRadiusMeters) {
            candidates.push({
              tweet: t,
              distance: distance,
            });
          }
        }

        candidates.sort(function (a, b) {
          return a.distance - b.distance;
        });

        clearMarkers();

        const count = Math.min(maxMarkers, candidates.length);
        const nearestDistance = count > 0 ? Math.round(candidates[0].distance) : null;
        const headingNow = deviceHeading === null ? 0 : deviceHeading;
        const laneStepDeg = 2.8;
        const clusterStepDeg = 8.0;
        const laneSlots = new Map();
        const clusterSlots = new Map();
        function directedOffsetUnits(indexInGroup, ratio) {
          if (indexInGroup === 0) {
            return 0;
          }
          // Near tweets: spread upward only. Far tweets: spread downward only.
          if (ratio <= 0.45) {
            return indexInGroup;
          }
          if (ratio >= 0.7) {
            return -indexInGroup;
          }
          const level = Math.floor((indexInGroup + 1) / 2);
          const sign = indexInGroup % 2 === 1 ? 1 : -1;
          return level * sign;
        }
        nearbyCandidateCount = candidates.length;
        renderedMarkerCount = count;
        nearestDistanceMeters = nearestDistance;
        for (let i = 0; i < count; i++) {
          const candidate = candidates[i];
          const t = candidate.tweet;
          const distance = candidate.distance;
          const bearing = bearingDegrees(lat, lon, t.lat, t.lon);
          const relativeDeg = ((bearing - headingNow + 540) % 360) - 180;
          const relativeRad = (relativeDeg * Math.PI) / 180;
          // Compress depth harder so vertical placement is visible on screen.
          const projected = clamp(distance * 0.032, 6, 30);
          const x = Math.sin(relativeRad) * projected;
          const z = -Math.cos(relativeRad) * projected;
          const ratio = clamp(distance / markerRadiusMeters, 0, 1);
          const laneKey = String(Math.round(relativeDeg / laneStepDeg));
          const laneIndex = laneSlots.get(laneKey) || 0;
          laneSlots.set(laneKey, laneIndex + 1);
          const clusterKey = String(Math.round(relativeDeg / clusterStepDeg));
          const clusterIndex = clusterSlots.get(clusterKey) || 0;
          clusterSlots.set(clusterKey, clusterIndex + 1);
          // Distance-driven vertical band: map near->top and far->bottom over the full viewport range.
          const topBandY = 39.0;
          const bottomBandY = -84.0;
          const distanceCurve = Math.pow(ratio, 0.86);
          const baseY = topBandY + (bottomBandY - topBandY) * distanceCurve - 3.9;
          const spreadStep = clamp(7.5 - ratio * 1.35, 5.4, 7.5);
          const laneOffset = directedOffsetUnits(laneIndex, ratio);
          const clusterOffset = directedOffsetUnits(clusterIndex, ratio);
          const densityBoost = 1 + Math.min(3.2, clusterIndex * 0.34 + laneIndex * 0.2);
          const combinedOffset = laneOffset + clusterOffset * 1.8;
          const directionalBias = ratio <= 0.45 ? clusterIndex * 1.13 : ratio >= 0.7 ? -clusterIndex * 2.18 : 0;
          const markerY = clamp(baseY + (combinedOffset + directionalBias) * spreadStep * densityBoost, -93.0, 48.0);
          const iconSize = clamp(2.7 - ratio * 1.2, 1.5, 2.7);
          const label = toLabel(t.text);
          const baseLabelFontPx = (90 + ratio * 140) * 1.5;
          const distanceFontScale = 1 - ratio * 0.5;
          const labelFontPx = Math.round(baseLabelFontPx * distanceFontScale);
          const labelTexture = labelTextureDataUrl(label, labelFontPx);
          const labelHeight = clamp(3.4 + ratio * 2.6, 3.4, 6.0);
          const labelWidth = clamp(labelHeight * labelTexture.aspect, 4.8, 64.0);
          const iconOpacity = clamp(0.92 - ratio * 0.64, 0.28, 0.92);
          const labelOpacity = clamp(0.98 - ratio * 0.7, 0.24, 0.98);

          const root = document.createElement("a-entity");
          root.setAttribute("position", x.toFixed(2) + " " + markerY.toFixed(2) + " " + z.toFixed(2));
          root.setAttribute("rotation", "0 " + yawDegreesFacingUser(x, z).toFixed(2) + " 0");
          root.setAttribute("class", "tweet-hit");

          const icon = document.createElement("a-image");
          icon.setAttribute("class", "tweet-icon tweet-hit");
          icon.setAttribute("src", "#twitterIconAsset");
          icon.setAttribute("width", iconSize.toFixed(2));
          icon.setAttribute("height", iconSize.toFixed(2));
          icon.setAttribute("material", "transparent: true; side: double; alphaTest: 0.2; shader: flat;");
          icon.setAttribute("position", "0 0 0");
          icon.setAttribute("opacity", iconOpacity.toFixed(2));
          root.appendChild(icon);

          const labelImage = document.createElement("a-image");
          labelImage.setAttribute("class", "tweet-label tweet-hit");
          labelImage.setAttribute("src", labelTexture.url);
          labelImage.setAttribute("width", labelWidth.toFixed(2));
          labelImage.setAttribute("height", labelHeight.toFixed(2));
          labelImage.setAttribute("material", "transparent: true; side: double; alphaTest: 0.02; shader: flat;");
          labelImage.setAttribute("position", "0 " + (iconSize * 0.8 + 1.75).toFixed(2) + " 0.02");
          labelImage.setAttribute("opacity", labelOpacity.toFixed(2));
          root.appendChild(labelImage);
          root.dataset.iconOpacity = iconOpacity.toFixed(2);
          root.dataset.labelOpacity = labelOpacity.toFixed(2);
          root.dataset.tweetText = t.text;
          root.dataset.distanceMeters = String(Math.round(distance));
          const onSelect = function () {
            selectMarker(root);
          };
          root.addEventListener("click", onSelect);
          root.addEventListener("touchstart", onSelect, { passive: true });
          icon.addEventListener("click", onSelect);
          icon.addEventListener("touchstart", onSelect, { passive: true });
          labelImage.addEventListener("click", onSelect);
          labelImage.addEventListener("touchstart", onSelect, { passive: true });

          markerEntities.push(root);
          scene.appendChild(root);
        }
        const nearestText = nearestDistance !== null ? ", 最短 " + nearestDistance + "m" : "";
        const message =
          "近傍 " +
          candidates.length +
          " 件（表示 " +
          count +
          " 件, 半径 " +
          Math.round(markerRadiusMeters / 1000) +
          "km" +
          nearestText +
          "）";
        setStatus(message);
        lastBuildPosition = {
          latitude: lat,
          longitude: lon,
        };
      }

      function maybeRebuildMarkers() {
        if (!currentPosition) {
          return;
        }
        if (!lastBuildPosition) {
          scheduleBuild(true);
          return;
        }

        const moved = haversineMeters(
          lastBuildPosition.latitude,
          lastBuildPosition.longitude,
          currentPosition.coords.latitude,
          currentPosition.coords.longitude
        );
        if (moved >= rebuildThresholdMeters) {
          scheduleBuild(false);
        }
      }

      function loadTweets() {
        return fetch(tweetDataUrl)
          .then(function (response) {
            if (!response.ok) {
              throw new Error("HTTP " + response.status);
            }
            return response.json();
          })
          .then(function (json) {
            const tweets = [];
            for (let i = 0; i < json.length; i++) {
              const item = json[i];
              const coords = item && item.position && item.position.cartographicDegrees;
              if (!Array.isArray(coords) || coords.length < 2) {
                continue;
              }
              const lon = Number(coords[0]);
              const lat = Number(coords[1]);
              if (!Number.isFinite(lon) || !Number.isFinite(lat)) {
                continue;
              }
              tweets.push({
                id: String(item.id),
                text: String(item.text || ""),
                lat: lat,
                lon: lon,
              });
            }
            allTweets = tweets;
            dataLoaded = true;
          });
      }

      function requestOrientationPermission() {
        if (typeof DeviceOrientationEvent === "undefined") {
          return Promise.resolve();
        }
        if (typeof DeviceOrientationEvent.requestPermission !== "function") {
          return Promise.resolve();
        }
        return DeviceOrientationEvent.requestPermission().then(function (state) {
          if (state !== "granted") {
            throw new Error("方位センサー権限が拒否されました。");
          }
        });
      }

      function bindOrientationDiagnostics() {
        window.addEventListener(
          "deviceorientation",
          function (event) {
            if (typeof event.webkitCompassHeading === "number") {
              deviceHeading = event.webkitCompassHeading;
            } else if (event.absolute && typeof event.alpha === "number") {
              deviceHeading = (360 - event.alpha) % 360;
            }
            if (deviceHeading !== null && currentPosition && dataLoaded && !lastBuildPosition && markerEntities.length === 0) {
              scheduleBuild(true);
            }
          },
          true
        );
      }

      function requestCameraPermission() {
        if (!navigator.mediaDevices || typeof navigator.mediaDevices.getUserMedia !== "function") {
          return Promise.resolve();
        }

        return navigator.mediaDevices
          .getUserMedia({
            video: {
              facingMode: { ideal: "environment" },
            },
            audio: false,
          })
          .then(function (stream) {
            cameraStream = stream;
            cameraFeed.srcObject = stream;
            return cameraFeed.play().catch(function () {
              return Promise.resolve();
            });
          });
      }

      function startLocationPolling() {
        if (!navigator.geolocation) {
          setStatus("この端末は位置情報に対応していません。");
          return;
        }

        const pollPosition = function () {
          navigator.geolocation.getCurrentPosition(
            function (position) {
              currentPosition = position;
              maybeRebuildMarkers();
            },
            function (error) {
              setStatus("位置情報の取得に失敗: " + error.message);
            },
            {
              enableHighAccuracy: false,
              maximumAge: locationPollIntervalMs,
              timeout: 30000,
            }
          );
        };

        pollPosition();
        locationPollTimer = setInterval(pollPosition, locationPollIntervalMs);
      }

      function startAR() {
        setStatus("データ読み込み中...");
        startButton.disabled = true;
        const orientationPermissionPromise = requestOrientationPermission();
        Promise.all([orientationPermissionPromise, requestCameraPermission()])
          .then(function () {
            return loadTweets();
          })
          .then(function () {
            setStatus("位置情報を取得しています...");
            createScene();
            bindOrientationDiagnostics();
            startLocationPolling();
            startButton.textContent = "起動中";
            setTimeout(function () {
              if (!cameraStream) {
                setStatus("カメラ映像を取得できません。Safari設定のカメラ許可を確認してください。");
              }
            }, 5000);
          })
          .catch(function (error) {
            setStatus("開始できませんでした: " + error.message);
            startButton.disabled = false;
            startButton.textContent = "開始";
          });
      }

      window.addEventListener("pagehide", function () {
        if (buildTimer !== null) {
          clearTimeout(buildTimer);
          buildTimer = null;
        }
        if (locationPollTimer !== null) {
          clearInterval(locationPollTimer);
          locationPollTimer = null;
        }
        if (!cameraStream) {
          return;
        }
        const tracks = cameraStream.getTracks ? cameraStream.getTracks() : [];
        for (let i = 0; i < tracks.length; i++) {
          tracks[i].stop();
        }
        cameraStream = null;
      });

      startButton.addEventListener("click", startAR);
    })();
  </script>
</body>
</html>
