<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no">
  <title>東日本大震災ツイートAR</title>
  <style>
    html, body {
      margin: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: "Hiragino Sans", "Yu Gothic", sans-serif;
      background: #000;
      color: #f3f6fa;
    }

    #arScene {
      position: fixed;
      inset: 0;
      z-index: 1;
    }

    #cameraFeed {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      z-index: 0;
      background: #000;
    }

    .overlay {
      position: fixed;
      left: 0;
      right: 0;
      z-index: 3;
      pointer-events: none;
    }

    #topPanel {
      top: 0;
      padding: 12px;
      display: flex;
      justify-content: center;
    }

    #statusCard {
      max-width: 90vw;
      min-width: 280px;
      border: 1px solid rgba(255, 255, 255, 0.28);
      border-radius: 12px;
      background: rgba(20, 24, 30, 0.72);
      box-shadow: 0 4px 14px rgba(0, 0, 0, 0.22);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      padding: 10px 12px;
      pointer-events: auto;
    }

    #statusText {
      margin: 0;
      font-size: 13px;
      line-height: 1.5;
    }

    #startButton {
      margin-top: 8px;
      border: 1px solid rgba(255, 255, 255, 0.35);
      border-radius: 8px;
      background: rgba(52, 114, 168, 0.76);
      color: #f3f6fa;
      height: 34px;
      padding: 0 14px;
      font-size: 13px;
      cursor: pointer;
    }

    #bottomPanel {
      bottom: 0;
      padding: 12px;
      display: flex;
      justify-content: center;
    }

    #tweetCard {
      width: min(92vw, 440px);
      min-height: 48px;
      border: 1px solid rgba(255, 255, 255, 0.28);
      border-radius: 12px;
      background: rgba(20, 24, 30, 0.72);
      box-shadow: 0 4px 14px rgba(0, 0, 0, 0.22);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      padding: 10px 12px;
      pointer-events: auto;
      opacity: 0;
      visibility: hidden;
      transform: translateY(10px);
      transition: opacity 240ms ease, transform 240ms ease, visibility 240ms ease;
    }

    #tweetCard.visible {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
    }

    #tweetBody {
      margin: 0;
      font-size: 13px;
      line-height: 1.45;
      color: #f3f6fa;
      white-space: pre-wrap;
      word-break: break-word;
    }

    #tweetMeta {
      margin: 8px 0 0 0;
      font-size: 12px;
      line-height: 1.3;
      color: rgba(243, 246, 250, 0.9);
      letter-spacing: 0.02em;
    }
  </style>
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/ar.js@3.4.5/aframe/build/aframe-ar.js"></script>
</head>
<body>
  <div class="overlay" id="topPanel">
    <div id="statusCard">
      <p id="statusText">「開始」を押してカメラ・位置情報を許可してください。</p>
      <button id="startButton" type="button">開始</button>
    </div>
  </div>

  <div class="overlay" id="bottomPanel">
    <div id="tweetCard">
      <p id="tweetBody">近くのツイートが見つかるとここに本文を表示します。</p>
      <p id="tweetMeta">ここから -m</p>
    </div>
  </div>

  <video id="cameraFeed" autoplay playsinline muted></video>
  <div id="arRoot"></div>

  <script>
    (function () {
      const statusText = document.getElementById("statusText");
      const startButton = document.getElementById("startButton");
      const tweetCard = document.getElementById("tweetCard");
      const tweetBody = document.getElementById("tweetBody");
      const tweetMeta = document.getElementById("tweetMeta");
      const arRoot = document.getElementById("arRoot");
      const cameraFeed = document.getElementById("cameraFeed");

      const tweetDataUrl = "data/czml/tweets.json";
      const twitterIconUrl = "data/icon/flags/twitter.png";
      const maxMarkers = 100;
      const markerRadiusMeters = 10000;
      const rebuildThresholdMeters = 30;
      const locationPollIntervalMs = 5000;
      const headingRebuildThresholdDeg = 9;
      const minBuildIntervalMs = 1200;
      const billboardIntervalMs = 300;

      let allTweets = [];
      let currentPosition = null;
      let lastBuildPosition = null;
      let markerEntities = [];
      let dataLoaded = false;
      let scene = null;
      let cameraStream = null;
      let locationPollTimer = null;
      let deviceHeading = null;
      let lastHeadingForBuild = null;
      let renderedMarkerCount = 0;
      let nearbyCandidateCount = 0;
      let nearestDistanceMeters = null;
      let selectedMarker = null;
      const labelTextureCache = new Map();
      let lastBuildAt = 0;
      let buildTimer = null;
      let lastBillboardAt = 0;
      let billboardTimer = null;
      const billboardTarget = new THREE.Vector3();

      function updateBillboards(force) {
        if (!scene || markerEntities.length === 0) {
          return;
        }
        const now = Date.now();
        if (!force && now - lastBillboardAt < billboardIntervalMs) {
          return;
        }
        const cam = scene.querySelector("#arCamera");
        if (!cam || !cam.object3D) {
          return;
        }
        cam.object3D.getWorldPosition(billboardTarget);
        for (let i = 0; i < markerEntities.length; i++) {
          const marker = markerEntities[i];
          if (marker && marker.object3D) {
            marker.object3D.lookAt(billboardTarget);
          }
        }
        lastBillboardAt = now;
      }

      function scheduleBuild(forceNow) {
        if (forceNow) {
          if (buildTimer !== null) {
            clearTimeout(buildTimer);
            buildTimer = null;
          }
          buildMarkers();
          return;
        }
        const wait = Math.max(0, minBuildIntervalMs - (Date.now() - lastBuildAt));
        if (wait === 0) {
          buildMarkers();
          return;
        }
        if (buildTimer !== null) {
          return;
        }
        buildTimer = setTimeout(function () {
          buildTimer = null;
          buildMarkers();
        }, wait);
      }

      function setStatus(message) {
        statusText.textContent = message;
      }

      function bindSceneEvents(targetScene) {
        targetScene.addEventListener("loaded", function () {
          setStatus("ARシーン起動完了。位置情報を待っています...");
        });
        const onBackgroundTap = function (event) {
          if (!isTweetHitTarget(event.target)) {
            clearSelection();
          }
        };
        targetScene.addEventListener("click", onBackgroundTap);
        targetScene.addEventListener("touchstart", onBackgroundTap, { passive: true });
      }

      function createScene() {
        arRoot.innerHTML =
          '<a-scene id="arScene" embedded vr-mode-ui="enabled: false" renderer="antialias: true; alpha: true; logarithmicDepthBuffer: true;">' +
          '<a-assets timeout="10000"><img id="twitterIconAsset" src="' +
          twitterIconUrl +
          '" crossorigin="anonymous"></a-assets>' +
          '<a-entity id="arCamera" camera look-controls="enabled: true; magicWindowTrackingEnabled: true; touchEnabled: true" wasd-controls="enabled: false" cursor="rayOrigin: mouse" raycaster="objects: .tweet-hit; far: 1000" position="0 1.6 0"></a-entity>' +
          "</a-scene>";
        scene = document.getElementById("arScene");
        bindSceneEvents(scene);
      }

      function haversineMeters(lat1, lon1, lat2, lon2) {
        const toRad = Math.PI / 180.0;
        const dLat = (lat2 - lat1) * toRad;
        const dLon = (lon2 - lon1) * toRad;
        const a =
          Math.sin(dLat / 2) * Math.sin(dLat / 2) +
          Math.cos(lat1 * toRad) * Math.cos(lat2 * toRad) *
          Math.sin(dLon / 2) * Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return 6371000 * c;
      }

      function bearingDegrees(lat1, lon1, lat2, lon2) {
        const toRad = Math.PI / 180.0;
        const y = Math.sin((lon2 - lon1) * toRad) * Math.cos(lat2 * toRad);
        const x =
          Math.cos(lat1 * toRad) * Math.sin(lat2 * toRad) -
          Math.sin(lat1 * toRad) * Math.cos(lat2 * toRad) * Math.cos((lon2 - lon1) * toRad);
        const brng = (Math.atan2(y, x) * 180) / Math.PI;
        return (brng + 360) % 360;
      }

      function clamp(value, min, max) {
        return Math.min(max, Math.max(min, value));
      }

      function angularDiffDeg(a, b) {
        const d = Math.abs(((a - b + 540) % 360) - 180);
        return d;
      }

      function clearMarkers() {
        if (!scene) {
          return;
        }
        clearSelection();
        if (buildTimer !== null) {
          clearTimeout(buildTimer);
          buildTimer = null;
        }
        for (let i = 0; i < markerEntities.length; i++) {
          const marker = markerEntities[i];
          if (marker.parentNode) {
            marker.parentNode.removeChild(marker);
          }
        }
        markerEntities = [];
      }

      function toLabel(text) {
        return String(text || "").replace(/\s+/g, " ").trim();
      }

      function wrapTextByWidth(ctx, text, maxWidth) {
        const lines = [];
        let line = "";
        for (let i = 0; i < text.length; i++) {
          const next = line + text[i];
          if (line && ctx.measureText(next).width > maxWidth) {
            lines.push(line);
            line = text[i];
          } else {
            line = next;
          }
        }
        if (line) {
          lines.push(line);
        }
        return lines.length > 0 ? lines : [text];
      }

      function labelTextureDataUrl(labelText) {
        if (labelTextureCache.has(labelText)) {
          return labelTextureCache.get(labelText);
        }
        const canvas = document.createElement("canvas");
        canvas.width = 2048;
        canvas.height = 512;
        const ctx = canvas.getContext("2d");
        if (!ctx) {
          return { url: "", aspect: 4.0 };
        }
        const fontPx = 118;
        const lineHeight = Math.round(fontPx * 1.22);
        const marginX = 80;
        const marginY = 56;
        const maxTextWidth = canvas.width - marginX * 2;
        ctx.font = "bold " + fontPx + "px 'Hiragino Sans', 'Yu Gothic', 'Noto Sans JP', sans-serif";
        const lines = wrapTextByWidth(ctx, labelText, maxTextWidth);
        const requiredHeight = marginY * 2 + lineHeight * lines.length;
        canvas.height = Math.max(256, Math.min(2048, requiredHeight));
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.font = "bold " + fontPx + "px 'Hiragino Sans', 'Yu Gothic', 'Noto Sans JP', sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "top";
        ctx.lineJoin = "round";
        ctx.lineWidth = 22;
        ctx.strokeStyle = "rgba(0,0,0,0.68)";
        const blockHeight = lineHeight * lines.length;
        let y = Math.round((canvas.height - blockHeight) * 0.5);
        for (let i = 0; i < lines.length; i++) {
          ctx.strokeText(lines[i], canvas.width / 2, y);
          y += lineHeight;
        }
        ctx.fillStyle = "#ffffff";
        y = Math.round((canvas.height - blockHeight) * 0.5);
        for (let i = 0; i < lines.length; i++) {
          ctx.fillText(lines[i], canvas.width / 2, y);
          y += lineHeight;
        }
        const texture = {
          url: canvas.toDataURL("image/png"),
          aspect: canvas.width / canvas.height,
        };
        labelTextureCache.set(labelText, texture);
        return texture;
      }

      function setMarkerSelected(marker, selected) {
        if (!marker) {
          return;
        }
        const icon = marker.querySelector(".tweet-icon");
        const label = marker.querySelector(".tweet-label");
        const iconBaseOpacity = marker.dataset.iconOpacity || "0.86";
        const labelBaseOpacity = marker.dataset.labelOpacity || "0.9";
        if (icon) {
          icon.setAttribute("opacity", selected ? "1.0" : iconBaseOpacity);
        }
        if (label) {
          label.setAttribute("opacity", selected ? "1.0" : labelBaseOpacity);
        }
        if (selected) {
          marker.setAttribute("animation__pulse", "property: scale; dir: alternate; dur: 520; easing: easeInOutSine; loop: true; to: 1.09 1.09 1.09");
        } else {
          marker.removeAttribute("animation__pulse");
          marker.setAttribute("scale", "1 1 1");
        }
      }

      function clearSelection() {
        if (selectedMarker) {
          setMarkerSelected(selectedMarker, false);
          selectedMarker = null;
        }
        tweetCard.classList.remove("visible");
      }

      function isTweetHitTarget(target) {
        let node = target;
        while (node && node !== scene) {
          if (node.classList && node.classList.contains("tweet-hit")) {
            return true;
          }
          node = node.parentElement;
        }
        return false;
      }

      function selectMarker(marker) {
        if (!marker) {
          return;
        }
        if (selectedMarker && selectedMarker !== marker) {
          setMarkerSelected(selectedMarker, false);
        }
        selectedMarker = marker;
        setMarkerSelected(marker, true);
        const body = marker.dataset.tweetText || "";
        const dist = marker.dataset.distanceMeters || "-";
        tweetBody.textContent = body;
        tweetMeta.textContent = "ここから " + dist + "m";
        tweetCard.classList.add("visible");
      }

      function buildMarkers() {
        if (!scene || !currentPosition || !dataLoaded) {
          return;
        }
        lastBuildAt = Date.now();

        const lat = currentPosition.coords.latitude;
        const lon = currentPosition.coords.longitude;
        const candidates = [];

        for (let i = 0; i < allTweets.length; i++) {
          const t = allTweets[i];
          const distance = haversineMeters(lat, lon, t.lat, t.lon);
          if (distance <= markerRadiusMeters) {
            candidates.push({
              tweet: t,
              distance: distance,
            });
          }
        }

        candidates.sort(function (a, b) {
          return a.distance - b.distance;
        });

        clearMarkers();

        const count = Math.min(maxMarkers, candidates.length);
        const nearestDistance = count > 0 ? Math.round(candidates[0].distance) : null;
        const headingNow = deviceHeading === null ? 0 : deviceHeading;
        const laneStepDeg = 2.8;
        const clusterStepDeg = 8.0;
        const laneSlots = new Map();
        const clusterSlots = new Map();
        function directedOffsetUnits(indexInGroup, ratio) {
          if (indexInGroup === 0) {
            return 0;
          }
          // Near tweets: spread upward only. Far tweets: spread downward only.
          if (ratio <= 0.45) {
            return indexInGroup;
          }
          if (ratio >= 0.7) {
            return -indexInGroup;
          }
          const level = Math.floor((indexInGroup + 1) / 2);
          const sign = indexInGroup % 2 === 1 ? 1 : -1;
          return level * sign;
        }
        nearbyCandidateCount = candidates.length;
        renderedMarkerCount = count;
        nearestDistanceMeters = nearestDistance;
        lastHeadingForBuild = headingNow;
        for (let i = 0; i < count; i++) {
          const candidate = candidates[i];
          const t = candidate.tweet;
          const distance = candidate.distance;
          const bearing = bearingDegrees(lat, lon, t.lat, t.lon);
          const relativeDeg = ((bearing - headingNow + 540) % 360) - 180;
          const relativeRad = (relativeDeg * Math.PI) / 180;
          // Virtual-depth compression to keep markers readable at long ranges.
          const projected = clamp(distance * 0.045, 8, 42);
          const x = Math.sin(relativeRad) * projected;
          const z = -Math.cos(relativeRad) * projected;
          const ratio = clamp(distance / markerRadiusMeters, 0, 1);
          const laneKey = String(Math.round(relativeDeg / laneStepDeg));
          const laneIndex = laneSlots.get(laneKey) || 0;
          laneSlots.set(laneKey, laneIndex + 1);
          const clusterKey = String(Math.round(relativeDeg / clusterStepDeg));
          const clusterIndex = clusterSlots.get(clusterKey) || 0;
          clusterSlots.set(clusterKey, clusterIndex + 1);
          // Distance-driven vertical band: near on top, far on bottom.
          const baseY = 8.6 - ratio * 18.0;
          const spreadStep = clamp(3.6 - ratio * 1.2, 2.1, 3.6);
          const laneOffset = directedOffsetUnits(laneIndex, ratio);
          const clusterOffset = directedOffsetUnits(clusterIndex, ratio);
          const densityBoost = 1 + Math.min(3.2, clusterIndex * 0.34 + laneIndex * 0.2);
          const combinedOffset = laneOffset + clusterOffset * 1.8;
          const directionalBias = ratio <= 0.45 ? clusterIndex * 0.45 : ratio >= 0.7 ? -clusterIndex * 0.55 : 0;
          const markerY = clamp(baseY + (combinedOffset + directionalBias) * spreadStep * densityBoost, -16.0, 14.0);
          const iconSize = clamp(2.7 - ratio * 1.2, 1.5, 2.7);
          const label = toLabel(t.text);
          const labelTexture = labelTextureDataUrl(label);
          const labelHeight = clamp(3.9 - ratio * 2.0, 1.9, 3.9);
          const labelWidth = clamp(labelHeight * labelTexture.aspect, 2.4, 26.0);
          const iconOpacity = clamp(0.9 - ratio * 0.38, 0.52, 0.9);
          const labelOpacity = clamp(0.96 - ratio * 0.44, 0.52, 0.96);

          const root = document.createElement("a-entity");
          root.setAttribute("position", x.toFixed(2) + " " + markerY.toFixed(2) + " " + z.toFixed(2));
          root.setAttribute("class", "tweet-hit");

          const icon = document.createElement("a-image");
          icon.setAttribute("class", "tweet-icon tweet-hit");
          icon.setAttribute("src", "#twitterIconAsset");
          icon.setAttribute("width", iconSize.toFixed(2));
          icon.setAttribute("height", iconSize.toFixed(2));
          icon.setAttribute("material", "transparent: true; side: double; alphaTest: 0.2; shader: flat;");
          icon.setAttribute("position", "0 0 0");
          icon.setAttribute("opacity", iconOpacity.toFixed(2));
          root.appendChild(icon);

          const labelImage = document.createElement("a-image");
          labelImage.setAttribute("class", "tweet-label tweet-hit");
          labelImage.setAttribute("src", labelTexture.url);
          labelImage.setAttribute("width", labelWidth.toFixed(2));
          labelImage.setAttribute("height", labelHeight.toFixed(2));
          labelImage.setAttribute("material", "transparent: true; side: double; alphaTest: 0.02; shader: flat;");
          labelImage.setAttribute("position", "0 " + (iconSize * 0.8 + 1.75).toFixed(2) + " 0.02");
          labelImage.setAttribute("opacity", labelOpacity.toFixed(2));
          root.appendChild(labelImage);
          root.dataset.iconOpacity = iconOpacity.toFixed(2);
          root.dataset.labelOpacity = labelOpacity.toFixed(2);
          root.dataset.tweetText = t.text;
          root.dataset.distanceMeters = String(Math.round(distance));
          const onSelect = function () {
            selectMarker(root);
          };
          root.addEventListener("click", onSelect);
          root.addEventListener("touchstart", onSelect, { passive: true });
          icon.addEventListener("click", onSelect);
          icon.addEventListener("touchstart", onSelect, { passive: true });
          labelImage.addEventListener("click", onSelect);
          labelImage.addEventListener("touchstart", onSelect, { passive: true });

          markerEntities.push(root);
          scene.appendChild(root);
        }
        updateBillboards(true);

        const nearestText = nearestDistance !== null ? ", 最短 " + nearestDistance + "m" : "";
        const message =
          "近傍 " +
          candidates.length +
          " 件（表示 " +
          count +
          " 件, 半径 " +
          Math.round(markerRadiusMeters / 1000) +
          "km" +
          nearestText +
          "）";
        setStatus(message);
        lastBuildPosition = {
          latitude: lat,
          longitude: lon,
        };
      }

      function maybeRebuildMarkers() {
        if (!currentPosition) {
          return;
        }
        if (!lastBuildPosition) {
          scheduleBuild(true);
          return;
        }

        const moved = haversineMeters(
          lastBuildPosition.latitude,
          lastBuildPosition.longitude,
          currentPosition.coords.latitude,
          currentPosition.coords.longitude
        );
        if (moved >= rebuildThresholdMeters) {
          scheduleBuild(false);
        }
      }

      function loadTweets() {
        return fetch(tweetDataUrl)
          .then(function (response) {
            if (!response.ok) {
              throw new Error("HTTP " + response.status);
            }
            return response.json();
          })
          .then(function (json) {
            const tweets = [];
            for (let i = 0; i < json.length; i++) {
              const item = json[i];
              const coords = item && item.position && item.position.cartographicDegrees;
              if (!Array.isArray(coords) || coords.length < 2) {
                continue;
              }
              const lon = Number(coords[0]);
              const lat = Number(coords[1]);
              if (!Number.isFinite(lon) || !Number.isFinite(lat)) {
                continue;
              }
              tweets.push({
                id: String(item.id),
                text: String(item.text || ""),
                lat: lat,
                lon: lon,
              });
            }
            allTweets = tweets;
            dataLoaded = true;
          });
      }

      function requestOrientationPermission() {
        if (typeof DeviceOrientationEvent === "undefined") {
          return Promise.resolve();
        }
        if (typeof DeviceOrientationEvent.requestPermission !== "function") {
          return Promise.resolve();
        }
        return DeviceOrientationEvent.requestPermission().then(function (state) {
          if (state !== "granted") {
            throw new Error("方位センサー権限が拒否されました。");
          }
        });
      }

      function bindOrientationDiagnostics() {
        window.addEventListener(
          "deviceorientation",
          function (event) {
            if (typeof event.webkitCompassHeading === "number") {
              deviceHeading = event.webkitCompassHeading;
            } else if (event.absolute && typeof event.alpha === "number") {
              deviceHeading = (360 - event.alpha) % 360;
            }
            if (
              deviceHeading !== null &&
              currentPosition &&
              dataLoaded &&
              (lastHeadingForBuild === null || angularDiffDeg(deviceHeading, lastHeadingForBuild) >= headingRebuildThresholdDeg)
            ) {
              scheduleBuild(false);
            }
          },
          true
        );
      }

      function requestCameraPermission() {
        if (!navigator.mediaDevices || typeof navigator.mediaDevices.getUserMedia !== "function") {
          return Promise.resolve();
        }

        return navigator.mediaDevices
          .getUserMedia({
            video: {
              facingMode: { ideal: "environment" },
            },
            audio: false,
          })
          .then(function (stream) {
            cameraStream = stream;
            cameraFeed.srcObject = stream;
            return cameraFeed.play().catch(function () {
              return Promise.resolve();
            });
          });
      }

      function startLocationPolling() {
        if (!navigator.geolocation) {
          setStatus("この端末は位置情報に対応していません。");
          return;
        }

        const pollPosition = function () {
          navigator.geolocation.getCurrentPosition(
            function (position) {
              currentPosition = position;
              maybeRebuildMarkers();
            },
            function (error) {
              setStatus("位置情報の取得に失敗: " + error.message);
            },
            {
              enableHighAccuracy: false,
              maximumAge: locationPollIntervalMs,
              timeout: 30000,
            }
          );
        };

        pollPosition();
        locationPollTimer = setInterval(pollPosition, locationPollIntervalMs);
      }

      function startAR() {
        setStatus("データ読み込み中...");
        startButton.disabled = true;
        const orientationPermissionPromise = requestOrientationPermission();
        Promise.all([orientationPermissionPromise, requestCameraPermission()])
          .then(function () {
            return loadTweets();
          })
          .then(function () {
            setStatus("位置情報を取得しています...");
            createScene();
            bindOrientationDiagnostics();
            startLocationPolling();
            startButton.textContent = "起動中";
            if (billboardTimer === null) {
              billboardTimer = setInterval(function () {
                updateBillboards(false);
              }, billboardIntervalMs);
            }
            setTimeout(function () {
              if (!cameraStream) {
                setStatus("カメラ映像を取得できません。Safari設定のカメラ許可を確認してください。");
              }
            }, 5000);
          })
          .catch(function (error) {
            setStatus("開始できませんでした: " + error.message);
            startButton.disabled = false;
            startButton.textContent = "開始";
          });
      }

      window.addEventListener("pagehide", function () {
        if (buildTimer !== null) {
          clearTimeout(buildTimer);
          buildTimer = null;
        }
        if (billboardTimer !== null) {
          clearInterval(billboardTimer);
          billboardTimer = null;
        }
        if (locationPollTimer !== null) {
          clearInterval(locationPollTimer);
          locationPollTimer = null;
        }
        if (!cameraStream) {
          return;
        }
        const tracks = cameraStream.getTracks ? cameraStream.getTracks() : [];
        for (let i = 0; i < tracks.length; i++) {
          tracks[i].stop();
        }
        cameraStream = null;
      });

      startButton.addEventListener("click", startAR);
    })();
  </script>
</body>
</html>
