<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no">
  <title>東日本大震災ツイートAR</title>
  <style>
    html, body {
      margin: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: "Hiragino Sans", "Yu Gothic", sans-serif;
      background: #000;
      color: #f3f6fa;
    }

    #arScene {
      position: fixed;
      inset: 0;
      z-index: 1;
    }

    #cameraFeed {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      z-index: 0;
      background: #000;
    }

    .overlay {
      position: fixed;
      left: 0;
      right: 0;
      z-index: 3;
      pointer-events: none;
    }

    #topPanel {
      top: 0;
      padding: 12px;
      display: flex;
      justify-content: center;
    }

    #statusCard {
      max-width: 90vw;
      min-width: 280px;
      border: 1px solid rgba(255, 255, 255, 0.28);
      border-radius: 12px;
      background: rgba(20, 24, 30, 0.72);
      box-shadow: 0 4px 14px rgba(0, 0, 0, 0.22);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      padding: 10px 12px;
      pointer-events: auto;
    }

    #statusText {
      margin: 0;
      font-size: 13px;
      line-height: 1.5;
    }

    #startButton {
      margin-top: 8px;
      border: 1px solid rgba(255, 255, 255, 0.35);
      border-radius: 8px;
      background: rgba(52, 114, 168, 0.76);
      color: #f3f6fa;
      height: 34px;
      padding: 0 14px;
      font-size: 13px;
      cursor: pointer;
    }

    #diagText {
      margin: 8px 0 0 0;
      padding: 8px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      background: rgba(6, 10, 16, 0.55);
      color: #d8e6f7;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 11px;
      line-height: 1.35;
      white-space: pre-wrap;
      max-height: 24vh;
      overflow: auto;
    }

    #bottomPanel {
      bottom: 0;
      padding: 12px;
      display: flex;
      justify-content: center;
    }

    #tweetCard {
      width: min(92vw, 440px);
      min-height: 48px;
      border: 1px solid rgba(255, 255, 255, 0.28);
      border-radius: 12px;
      background: rgba(20, 24, 30, 0.72);
      box-shadow: 0 4px 14px rgba(0, 0, 0, 0.22);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      padding: 10px 12px;
      pointer-events: auto;
    }

    #tweetText {
      margin: 0;
      font-size: 13px;
      line-height: 1.45;
      color: #f3f6fa;
      word-break: break-word;
    }
  </style>
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/ar.js@3.4.5/aframe/build/aframe-ar.js"></script>
</head>
<body>
  <div class="overlay" id="topPanel">
    <div id="statusCard">
      <p id="statusText">「開始」を押してカメラ・位置情報を許可してください。</p>
      <button id="startButton" type="button">開始</button>
      <pre id="diagText">diag: waiting...</pre>
    </div>
  </div>

  <div class="overlay" id="bottomPanel">
    <div id="tweetCard">
      <p id="tweetText">近くのツイートが見つかるとここに本文を表示します。</p>
    </div>
  </div>

  <video id="cameraFeed" autoplay playsinline muted></video>
  <div id="arRoot"></div>

  <script>
    (function () {
      const statusText = document.getElementById("statusText");
      const startButton = document.getElementById("startButton");
      const tweetText = document.getElementById("tweetText");
      const arRoot = document.getElementById("arRoot");
      const cameraFeed = document.getElementById("cameraFeed");
      const diagText = document.getElementById("diagText");

      const tweetDataUrl = "data/czml/tweets.json";
      const twitterIconUrl = "data/icon/flags/twitter.png";
      const maxMarkers = 100;
      const markerRadiusMeters = 10000;
      const rebuildThresholdMeters = 120;

      let allTweets = [];
      let currentPosition = null;
      let lastBuildPosition = null;
      let markerEntities = [];
      let dataLoaded = false;
      let scene = null;
      let cameraStream = null;
      let watchId = null;
      let deviceHeading = null;
      let lastHeadingForBuild = null;
      let renderedMarkerCount = 0;
      let nearbyCandidateCount = 0;
      let nearestDistanceMeters = null;

      function setStatus(message) {
        statusText.textContent = message;
      }

      function toDeg(rad) {
        return (rad * 180) / Math.PI;
      }

      function fmtNum(v, digits) {
        if (v === null || v === undefined || Number.isNaN(Number(v))) {
          return "-";
        }
        return Number(v).toFixed(digits);
      }

      function updateDiag() {
        const lines = [];
        lines.push("mode: live diagnostics");
        lines.push("camera stream: " + (cameraStream ? "ok" : "none"));
        lines.push("tweets loaded: " + allTweets.length);
        lines.push("radius(m): " + markerRadiusMeters + " / maxMarkers: " + maxMarkers);
        lines.push("nearby: " + nearbyCandidateCount + " / rendered: " + renderedMarkerCount);
        lines.push("nearest(m): " + (nearestDistanceMeters === null ? "-" : nearestDistanceMeters));
        lines.push("device heading(deg): " + (deviceHeading === null ? "-" : fmtNum(deviceHeading, 1)));

        if (currentPosition && currentPosition.coords) {
          const c = currentPosition.coords;
          lines.push("lat/lon: " + fmtNum(c.latitude, 6) + ", " + fmtNum(c.longitude, 6));
          lines.push(
            "accuracy(m): " +
              fmtNum(c.accuracy, 1) +
              "  altitude(m): " +
              fmtNum(c.altitude, 1) +
              "  altAcc(m): " +
              fmtNum(c.altitudeAccuracy, 1)
          );
          lines.push("speed(m/s): " + fmtNum(c.speed, 2) + "  gps heading(deg): " + fmtNum(c.heading, 1));
          lines.push("pos timestamp: " + new Date(currentPosition.timestamp).toLocaleTimeString());
        } else {
          lines.push("position: waiting...");
        }

        if (scene) {
          const cam = scene.querySelector("#arCamera");
          if (cam && cam.object3D) {
            const r = cam.object3D.rotation;
            lines.push(
              "camera rot deg (x,y,z): " +
                fmtNum(toDeg(r.x), 1) +
                ", " +
                fmtNum(toDeg(r.y), 1) +
                ", " +
                fmtNum(toDeg(r.z), 1)
            );
          } else {
            lines.push("camera rot: -");
          }
        } else {
          lines.push("scene: not created");
        }

        lines.push("screen orientation: " + (screen.orientation ? screen.orientation.type : "-"));
        diagText.textContent = lines.join("\n");
      }

      function bindSceneEvents(targetScene) {
        targetScene.addEventListener("loaded", function () {
          setStatus("ARシーン起動完了。位置情報を待っています...");
          updateDiag();
        });
      }

      function createScene() {
        arRoot.innerHTML =
          '<a-scene id="arScene" embedded vr-mode-ui="enabled: false" renderer="antialias: true; alpha: true; logarithmicDepthBuffer: true;">' +
          '<a-entity id="arCamera" camera look-controls="enabled: true; magicWindowTrackingEnabled: true; touchEnabled: true" wasd-controls="enabled: false" position="0 1.6 0"></a-entity>' +
          "</a-scene>";
        scene = document.getElementById("arScene");
        bindSceneEvents(scene);
      }

      function haversineMeters(lat1, lon1, lat2, lon2) {
        const toRad = Math.PI / 180.0;
        const dLat = (lat2 - lat1) * toRad;
        const dLon = (lon2 - lon1) * toRad;
        const a =
          Math.sin(dLat / 2) * Math.sin(dLat / 2) +
          Math.cos(lat1 * toRad) * Math.cos(lat2 * toRad) *
          Math.sin(dLon / 2) * Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return 6371000 * c;
      }

      function bearingDegrees(lat1, lon1, lat2, lon2) {
        const toRad = Math.PI / 180.0;
        const y = Math.sin((lon2 - lon1) * toRad) * Math.cos(lat2 * toRad);
        const x =
          Math.cos(lat1 * toRad) * Math.sin(lat2 * toRad) -
          Math.sin(lat1 * toRad) * Math.cos(lat2 * toRad) * Math.cos((lon2 - lon1) * toRad);
        const brng = (Math.atan2(y, x) * 180) / Math.PI;
        return (brng + 360) % 360;
      }

      function clamp(value, min, max) {
        return Math.min(max, Math.max(min, value));
      }

      function angularDiffDeg(a, b) {
        const d = Math.abs(((a - b + 540) % 360) - 180);
        return d;
      }

      function clearMarkers() {
        if (!scene) {
          return;
        }
        for (let i = 0; i < markerEntities.length; i++) {
          const marker = markerEntities[i];
          if (marker.parentNode) {
            marker.parentNode.removeChild(marker);
          }
        }
        markerEntities = [];
      }

      function toLabel(text) {
        const trimmed = String(text || "").replace(/\s+/g, " ").trim();
        if (trimmed.length <= 18) {
          return trimmed;
        }
        return trimmed.slice(0, 18) + "...";
      }

      function buildMarkers() {
        if (!scene || !currentPosition || !dataLoaded) {
          return;
        }

        const lat = currentPosition.coords.latitude;
        const lon = currentPosition.coords.longitude;
        const candidates = [];

        for (let i = 0; i < allTweets.length; i++) {
          const t = allTweets[i];
          const distance = haversineMeters(lat, lon, t.lat, t.lon);
          if (distance <= markerRadiusMeters) {
            candidates.push({
              tweet: t,
              distance: distance,
            });
          }
        }

        candidates.sort(function (a, b) {
          return a.distance - b.distance;
        });

        clearMarkers();

        const count = Math.min(maxMarkers, candidates.length);
        const nearestDistance = count > 0 ? Math.round(candidates[0].distance) : null;
        const headingNow = deviceHeading === null ? 0 : deviceHeading;
        nearbyCandidateCount = candidates.length;
        renderedMarkerCount = count;
        nearestDistanceMeters = nearestDistance;
        lastHeadingForBuild = headingNow;
        for (let i = 0; i < count; i++) {
          const candidate = candidates[i];
          const t = candidate.tweet;
          const distance = candidate.distance;
          const bearing = bearingDegrees(lat, lon, t.lat, t.lon);
          const relativeDeg = ((bearing - headingNow + 540) % 360) - 180;
          const relativeRad = (relativeDeg * Math.PI) / 180;
          // Compress far distances so 10km scope still stays visible in camera space.
          const projected = clamp(distance * 0.32, 20, 260);
          const x = Math.sin(relativeRad) * projected;
          const z = -Math.cos(relativeRad) * projected;
          const ratio = clamp(distance / markerRadiusMeters, 0, 1);
          // Near markers on upper side, far markers near horizon (upper half area).
          const markerY = 8.2 - ratio * 6.2;
          const iconSize = clamp(2.8 - ratio * 1.8, 1.0, 2.8);
          const labelWidth = clamp(12.0 - ratio * 4.5, 7.0, 12.0);
          const labelHeight = clamp(2.8 - ratio * 1.2, 1.3, 2.8);
          const labelTextWidth = clamp(22.0 - ratio * 8.0, 10.0, 22.0);

          const root = document.createElement("a-entity");
          root.setAttribute("position", x.toFixed(2) + " " + markerY.toFixed(2) + " " + z.toFixed(2));

          const icon = document.createElement("a-image");
          icon.setAttribute("src", twitterIconUrl);
          icon.setAttribute("width", iconSize.toFixed(2));
          icon.setAttribute("height", iconSize.toFixed(2));
          icon.setAttribute("material", "transparent: true; side: double;");
          icon.setAttribute("position", "0 0 0");
          root.appendChild(icon);

          const panel = document.createElement("a-plane");
          panel.setAttribute("height", labelHeight.toFixed(2));
          panel.setAttribute("width", labelWidth.toFixed(2));
          panel.setAttribute("color", "#14181e");
          panel.setAttribute("opacity", "0.84");
          panel.setAttribute("material", "transparent: true; side: double;");
          panel.setAttribute("position", "0 " + (iconSize * 0.9 + labelHeight * 0.6).toFixed(2) + " 0");

          const text = document.createElement("a-text");
          text.setAttribute("value", toLabel(t.text));
          text.setAttribute("align", "center");
          text.setAttribute("color", "#f3f6fa");
          text.setAttribute("width", labelTextWidth.toFixed(2));
          text.setAttribute("position", "0 0 0.02");
          panel.appendChild(text);

          root.appendChild(panel);
          root.dataset.tweetText = t.text;
          root.addEventListener("click", function (event) {
            tweetText.textContent = event.currentTarget.dataset.tweetText || "";
          });

          markerEntities.push(root);
          scene.appendChild(root);
        }

        const nearestText = nearestDistance !== null ? ", 最短 " + nearestDistance + "m" : "";
        const message =
          "近傍 " +
          candidates.length +
          " 件（表示 " +
          count +
          " 件, 半径 " +
          Math.round(markerRadiusMeters / 1000) +
          "km" +
          nearestText +
          "）";
        setStatus(message);
        updateDiag();
        lastBuildPosition = {
          latitude: lat,
          longitude: lon,
        };
      }

      function maybeRebuildMarkers() {
        if (!currentPosition) {
          return;
        }
        if (!lastBuildPosition) {
          buildMarkers();
          return;
        }

        const moved = haversineMeters(
          lastBuildPosition.latitude,
          lastBuildPosition.longitude,
          currentPosition.coords.latitude,
          currentPosition.coords.longitude
        );
        if (moved >= rebuildThresholdMeters) {
          buildMarkers();
        }
      }

      function loadTweets() {
        return fetch(tweetDataUrl)
          .then(function (response) {
            if (!response.ok) {
              throw new Error("HTTP " + response.status);
            }
            return response.json();
          })
          .then(function (json) {
            const tweets = [];
            for (let i = 0; i < json.length; i++) {
              const item = json[i];
              const coords = item && item.position && item.position.cartographicDegrees;
              if (!Array.isArray(coords) || coords.length < 2) {
                continue;
              }
              const lon = Number(coords[0]);
              const lat = Number(coords[1]);
              if (!Number.isFinite(lon) || !Number.isFinite(lat)) {
                continue;
              }
              tweets.push({
                id: String(item.id),
                text: String(item.text || ""),
                lat: lat,
                lon: lon,
              });
            }
            allTweets = tweets;
            dataLoaded = true;
          });
      }

      function requestOrientationPermission() {
        if (typeof DeviceOrientationEvent === "undefined") {
          return Promise.resolve();
        }
        if (typeof DeviceOrientationEvent.requestPermission !== "function") {
          return Promise.resolve();
        }
        return DeviceOrientationEvent.requestPermission().then(function (state) {
          if (state !== "granted") {
            throw new Error("方位センサー権限が拒否されました。");
          }
        });
      }

      function bindOrientationDiagnostics() {
        window.addEventListener(
          "deviceorientation",
          function (event) {
            if (typeof event.webkitCompassHeading === "number") {
              deviceHeading = event.webkitCompassHeading;
            } else if (event.absolute && typeof event.alpha === "number") {
              deviceHeading = (360 - event.alpha) % 360;
            }
            if (
              deviceHeading !== null &&
              currentPosition &&
              dataLoaded &&
              (lastHeadingForBuild === null || angularDiffDeg(deviceHeading, lastHeadingForBuild) >= 2)
            ) {
              buildMarkers();
            }
            updateDiag();
          },
          true
        );
      }

      function requestCameraPermission() {
        if (!navigator.mediaDevices || typeof navigator.mediaDevices.getUserMedia !== "function") {
          return Promise.resolve();
        }

        return navigator.mediaDevices
          .getUserMedia({
            video: {
              facingMode: { ideal: "environment" },
            },
            audio: false,
          })
          .then(function (stream) {
            cameraStream = stream;
            cameraFeed.srcObject = stream;
            return cameraFeed.play().catch(function () {
              return Promise.resolve();
            });
          });
      }

      function startWatchPosition() {
        if (!navigator.geolocation) {
          setStatus("この端末は位置情報に対応していません。");
          return;
        }
        watchId = navigator.geolocation.watchPosition(
          function (position) {
            currentPosition = position;
            maybeRebuildMarkers();
            updateDiag();
          },
          function (error) {
            setStatus("位置情報の取得に失敗: " + error.message);
            updateDiag();
          },
          {
            enableHighAccuracy: true,
            maximumAge: 5000,
            timeout: 20000,
          }
        );
      }

      function startAR() {
        setStatus("データ読み込み中...");
        Promise.resolve()
          .then(requestCameraPermission)
          .then(requestOrientationPermission)
          .then(function () {
            return loadTweets();
          })
          .then(function () {
            setStatus("位置情報を取得しています...");
            createScene();
            bindOrientationDiagnostics();
            startWatchPosition();
            startButton.disabled = true;
            startButton.textContent = "起動中";
            setTimeout(function () {
              if (!cameraStream) {
                setStatus("カメラ映像を取得できません。Safari設定のカメラ許可を確認してください。");
              }
              updateDiag();
            }, 5000);
            updateDiag();
          })
          .catch(function (error) {
            setStatus("開始できませんでした: " + error.message);
            updateDiag();
          });
      }

      window.addEventListener("pagehide", function () {
        if (!cameraStream) {
          return;
        }
        const tracks = cameraStream.getTracks ? cameraStream.getTracks() : [];
        for (let i = 0; i < tracks.length; i++) {
          tracks[i].stop();
        }
        cameraStream = null;
        if (watchId !== null) {
          navigator.geolocation.clearWatch(watchId);
          watchId = null;
        }
      });

      setInterval(updateDiag, 1000);
      updateDiag();
      startButton.addEventListener("click", startAR);
    })();
  </script>
</body>
</html>
